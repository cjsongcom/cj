
#ifndef _CJTHREAD_H_
#define _CJTHREAD_H_

#ifdef WIN32
#define PTW32_STATIC_LIB				// link pthread32 library as static
#define PTW32_INCLUDE_WINDOWS_H

#ifndef _TIMESPEC_DEFINED
#define _TIMESPEC_DEFINED
#endif


#endif

#include <pthread.h>


#ifdef WIN32
CJEXTERNC void cjsleep_us(cjui us);   // 1s = 1000 * 1000
CJEXTERNC void cjsleep_ms(cjui ms);  // 1s = 1000

#else
CJEXTERNC	inline void cjsleep_us(cjui us) { 
	usleep(us); }
CJEXTERNC	inline void cjsleep_ms(cjui us) {
    #pragma error("impl not yet") }

#endif

CJEXTERNC cji cjatomic_inc(cji* out);
CJEXTERNC cji cjatomic_dec(cji* out);
CJEXTERNC cji cjthread_yield(void);

/*
pthread attr default value

detachstate :
 > PTHREAD_CREATE_JOINABLE ; Exit status and thread are preserved after the thread terminates.

stackaddr :
 > NULL  ; New thread has system-allocated stack address.

stacksize :
 > 1 megabyte ; New thread has system-defined stack size.

priority :
 > New thread inherits parent thread priority.

inheritsched :
 > PTHREAD_INHERIT_SCHED ; New thread inherits parent thread scheduling priority.

schedpolicy :
 > SCHED_OTHER ; New thread uses Solaris-defined fixed priority scheduling
               ; threads run until preempted by a higher-priority thread or until they block or yield.

scope :
 > PTHREAD_SCOPE_PROCESS ; New thread is unbound - not permanently attached to LWP

*/

/*
int pthread_create(pthread_t *restrict thread,
       const pthread_attr_t *restrict attr,
       void *(*start_routine)(void*), void *restrict arg);

void *start_routine(void *data)
{
    SomeStruct *info = data;
    ...main code for thread...
    return 0;
}
*/
CJEXTERNC typedef void *(*pfn_cjthread_run)(void* prm);

// MUST exit thread with calling cjthread_join()/cjthread_deatch(), or leak thread resource
#define cjthread_create(th_id, th_fn, th_prm)	pthread_create(th_id, cjNULL, th_fn, th_prm);

// can't wait thread with cjthread_join, thread resource will be free when exit
#define cjthread_create_detached(th_rst, th_id, th_fn, th_prm) { \
    pthread_attr_t __cjpth_attr_detached; \
    pthread_attr_init(&__cjpth_attr_detached); \
    pthread_attr_setdetachstate(&__cjpth_attr_detached, PTHREAD_CREATE_DETACHED); \
    th_rst = pthread_create(th_id, &__cjpth_attr_detached, th_fn, th_prm); \
    pthread_attr_destroy(&__cjpth_attr_detached); }

#define cjthread_cancel(th_id)					pthread_cancel(th_id)

#define cjthread_join(th_id, th_out_status)		pthread_join(th_id, th_out_status)
#define cjthread_detach(th_id)                  pthread_detach(th_id)

#define cjthread_exit(th_out_val)				pthread_exit(th_out_val)
#define cjthread_detach(th_id)					pthread_detach(th_id)

#define cjthread_get_current_tid()              pthread_self()

#define cjthread_id(x)                          pthread_t x;
#define cjthread_id_t                           pthread_t

//#define cjthread_t                              pthread_t


//
// condition
//

#define cjthread_cond(x)                        pthread_cond_t x;
#define cjthread_cond_t                         pthread_cond_t

#define cjthread_cond_init(cond)                pthread_cond_init(cond, cjNULL);

// result: EBUSY: thread that wait signal still exist in condition
#define cjthread_cond_destroy(cond)             pthread_cond_destroy(cond);

// awake one thread from threads that use same condition and wait signal
#define cjthread_cond_signal(cond)              pthread_cond_signal(cond);

// awake >> all thread << that wait condition signal
#define cjthread_cond_broadcast(cond)           pthread_cond_broadcast(cond);


//
// condition wait
//

// call: 1. unlock mutex   2. deactive thread and await signal
// after receive signal :  1. lock mutex  2. activate thread 
// result: ETIMEDOUT ,  EINTR : interrupt was generated by posix signal
#define cjthread_cond_wait(cond, mutex)         pthread_cond_wait(cond, mutex);
#define cjthread_cond_wait_timedwait(cond, mutex, abstime)      pthread_cond_timedwait(cond, mutex, abstime);

/* 
example)

pthread_mutex_t        mutex;
pthread_condition_t    cond;
int val;

void* send_signal(void*){
  while(1){
    pthread_mutex_lock(&mutex);
    pthread_cond_signal(&cond);

    val++;
    pthread_mutex_unlock(&mutex);
    sleep(1);
  }
}

void* wait_and_show_val(void*){
  while(1){
    pthread_mutex_lock(&mutex);
    pthread_cond_wait(&cond,&mutex);

    printf("val:%d\n", val);
    pthread_mutex_unlock(&mutex);
  }
}

int main(){
    pthread_t t1,t2;

    pthread_mutex_init(&mutex,NULL);
    pthread_cond_init(&cond,NULL);

    pthread_create(&t1, NULL, send_signal,NULL);
    pthread_create(&t2, NULL, wait_and_show_val,NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}







*/



//
// mutex
//

#define cjthread_mutex(x)				        pthread_mutex_t x;
#define cjthread_mutex_t			            pthread_mutex_t

// deny recursive lock, avoid dead lock : https://rein.kr/blog/archives/231
// PTHREAD_MUTEX_RECURSIVE_NP : https://rein.kr/blog/archives/648
#define cjthread_mutex_init(x)			pthread_mutex_init(x, cjNULL)
#define cjthread_mutex_destroy(x)		pthread_mutex_destroy(x)

#define cjthread_mutex_lock(x)			pthread_mutex_lock(x)
#define cjthread_mutex_unlock(x)		pthread_mutex_unlock(x)


#endif 
